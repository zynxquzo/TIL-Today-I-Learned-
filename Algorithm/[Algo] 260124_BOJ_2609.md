# 📚 오늘의 알고리즘 (2026.01.24)

## ✅ 오늘 푼 문제
- **백준 2609번**: [최대공약수와 최소공배수](https://www.acmicpc.net/problem/2609) (Bronze 1)

---

## 💻 내 풀이
```python
A, B = list(map(int, input().split()))
original_a = A
original_b = B
while B != 0:
    r = A % B
    A = B
    B = r
print(A) # A는 최대공약수
    
C = (original_a*original_b) // A
print(C)
```

## 📖 새로 배운 개념
### 1. 유클리드 호제법 (Euclidean Algorithm)
- 두 수의 최대공약수를 구하는 효율적인 알고리즘입니다.
- **원리**: `GCD(A, B) = GCD(B, A % B)`를 반복하여 나머지가 0이 될 때의 B가 최대공약수입니다.
- 이전에 배운 개념을 실제 문제에 적용해보면서 while 문으로 구현하는 방법을 익혔습니다.

### 2. 최소공배수 구하는 공식
- 최소공배수 = (A × B) / 최대공약수
- 두 수를 곱한 후 최대공약수로 나누면 최소공배수를 구할 수 있습니다.
- 정수 나눗셈 연산자 `//`를 사용하여 정수 결과를 얻었습니다.

### 3. 변수 값 백업의 중요성
- while 문을 거치면서 `A`와 `B`의 값이 계속 변경되기 때문에
- 최소공배수 계산을 위해 원래 값을 `original_a`, `original_b`에 미리 저장해두는 것이 필요하다는 점을 배웠습니다.

### 4. 들여쓰기(Indentation)의 중요성
- 파이썬에서 들여쓰기는 코드의 실행 시점을 결정합니다.
- `print(A)`가 while 문 안에 있으면 반복할 때마다 출력되고, while 문 밖에 있으면 반복이 끝난 후 한 번만 출력됩니다.
- 들여쓰기 하나로 프로그램의 동작이 완전히 달라질 수 있다는 점을 체감했습니다.

## 🤔 회고 (Self Feedback)
- 유클리드 호제법을 이전에 배웠던 개념이지만, 실제 문제에 적용하니 더 확실하게 이해가 되었습니다.
- 처음에 들여쓰기 실수로 while 문 안에서 print가 계속 실행되는 오류를 겪었지만, 선생님의 힌트로 스스로 문제를 발견하고 수정할 수 있어서 뿌듯했습니다.
- 변수 값이 변경되기 전에 백업해두는 습관이 중요하다는 것을 깨달았습니다. 앞으로 비슷한 상황에서 이 패턴을 활용할 수 있을 것 같습니다.
- 수학적 공식(최소공배수)을 코드로 구현하는 연습이 되었고, 알고리즘 문제가 수학과 밀접하게 연관되어 있다는 것을 다시 한번 느꼈습니다.
- 단계별로 문제를 나눠서 접근하는 습관이 점점 몸에 배고 있는 것 같아 앞으로도 이 방식을 계속 유지하고 싶습니다.
# 오늘의 알고리즘 (2026.01.31)

## 오늘 푼 문제

* **백준 11652번**: [카드](https://www.acmicpc.net/problem/11652) (Silver 4)

---

## 내 풀이
```python
import sys
N = int(sys.stdin.readline())
lst = []
for _ in range(N):
    n = int(sys.stdin.readline())
    lst.append(n)
    
count = {} # 카드에 적힌 숫자 : 등장 횟수

for n in lst:
    if n in count:
        count[n] += 1
    else:
        count[n] = 1

max_value = max(count.values())
max_count = [] # 가장 많이 등장한 카드의 정수

for key, value in count.items():
    if value == max_value:
        max_count.append(key)
        
print(min(max_count))
```

## 새로 배운 개념

### 1. 딕셔너리를 활용한 빈도수 카운팅 (복습)

* 예전에 배웠던 딕셔너리를 알고리즘 문제에 다시 적용해봤다.
* `{숫자: 등장횟수}` 형태로 저장하면 한 번의 순회로 모든 숫자의 빈도를 파악할 수 있다는 것을 다시 확인했다.
* `if n in count` 조건문으로 키의 존재 여부를 확인하고, 있으면 값을 증가시키고 없으면 새로 추가하는 패턴을 실제 문제에 적용해봤다.

### 2. 딕셔너리 메서드 활용법 재정리

* `count.values()`로 등장 횟수들만 가져와서 `max()`를 적용하는 방법을 익혔다.
* `count.items()`로 키와 값을 동시에 순회하면서 조건에 맞는 값을 필터링하는 로직을 구현했다.

### 3. 다단계 조건 처리 방법

* 가장 많이 등장한 수를 찾고, 그 중에서 가장 작은 수를 선택하는 두 가지 조건을 순차적으로 처리하는 방법을 배웠다.
* 한 번에 모든 조건을 처리하려고 하지 않고, 단계를 나누어 접근하니 훨씬 명확했다.

## 회고

* 딕셔너리는 이전에 배웠던 내용이지만 알고리즘 문제에서 오랜만에 사용하다 보니 처음에는 낯설게 느껴졌다. 하지만 이번 문제를 통해 다시 복습하면서 완벽히 이해가 된 것 같다.
* 처음 문제를 봤을 때는 어떻게 풀어야 할지 막막했고 답을 이해하기에 급급했다. 하지만 단계별로 하나씩 따라가다 보니 어떤 식으로 논리 구조를 이어나가야 할지 길이 보이기 시작했다.
* 아직 혼자서 처음부터 끝까지 풀기는 힘들지만, 이전보다는 각 단계에서 "왜 이렇게 해야 하는지", "다음에는 무엇을 해야 하는지"에 대해 스스로 생각해볼 수 있는 시간이 많아졌다.
* 앞으로도 비슷한 유형의 문제를 더 풀어보면서 딕셔너리를 활용한 빈도수 카운팅 패턴을 완전히 익히고 싶다.
# 오늘의 알고리즘 (2026.01.22)

## 오늘 푼 문제
- **백준 2748번**: [피보나치 수 2](https://www.acmicpc.net/problem/2748) (Bronze 1)

---

## 내 풀이 (Dynamic Programming 이용)

```python
import sys

# 1. n이 몇 번째인지 입력 (빠른 입력을 위해 sys 사용)
n = int(sys.stdin.readline())

# 2. 계산 결과 저장 리스트 만들기 (DP 테이블 초기화)
# n번 인덱스까지 접근하기 위해 (n+1)개의 방을 생성
dp = [0] * (n + 1)

# 3. 초기값 설정 (피보나치 수열의 시작점)
dp[0] = 0
if n >= 1:
    dp[1] = 1
    
# 4. 반복문을 통해 '기록하며' 계산하기 (Bottom-Up 방식)
for i in range(2, n + 1):
    # 점화식: f(n) = f(n-1) + f(n-2)
    # 현재 값은 앞의 두 숫자의 합
    dp[i] = dp[i-1] + dp[i-2]
    
# 5. n번째 피보나치 수 출력
print(dp[n])
```

## 새로 배운 개념
### 1. 점화식과 동적 계획법 (DP)
- 점화식: `f(n) = f(n-1) + f(n-2)` 처럼 이전 단계의 값을 이용해 현재 값을 구하는 수식을 의미합니다.
- DP (Dynamic Programming): 똑같은 계산을 반복하지 않기 위해, 한 번 구한 답을 리스트(보관함)에 저장해두고 필요할 때 꺼내 쓰는 효율적인 알고리즘 기법임을 익혔습니다.

### 2. sys.stdin.readline()의 필요성
- `input()`보다 처리 속도가 훨씬 빠릅니다.
- 데이터 입력 양이 많은 알고리즘 문제에서 **시간 초과**를 방지하기 위한 필수 도구이며, `import sys`를 통해 사용할 수 있습니다.

### 3. 리스트 초기화와 인덱스 범위
- `dp = [0] * (n + 1)` : 파이썬 리스트는 인덱스가 0부터 시작합니다. 따라서 `n`번째 값을 저장하려면 총 `n+1`개의 공간이 필요하다는 점을 배웠습니다.

## 덧붙임 (Self Feedback)
- 재귀 함수로 풀면 중복 계산 때문에 성능이 저하되지만, 리스트에 결과를 기록(Memoization)하는 것만으로도 계산 속도가 비약적으로 빨라진다는 점이 인상적이었습니다.- 점화식이라는 용어가 처음엔 생소했지만, "이미 구한 앞의 두 값을 더해 다음 값을 만든다"는 규칙을 코드로 구현해 보며 개념을 확실히 잡았습니다.
- 파이썬의 큰 정수 처리 능력 덕분에 `n=90`과 같은 큰 범위의 피보나치 수도 오버플로우 걱정 없이 구할 수 있다는 점이 편리했습니다.
# 오늘의 알고리즘 (2026.02.07)

## 오늘 푼 문제

* **백준 2493번**: [탑](https://www.acmicpc.net/problem/2493) (Gold 5)

---

## 내 풀이
```python
N = int(input())
top = list(map(int, input().split()))

stack = []  # (번호, 높이)를 저장할 스택
answer = []  # 정답을 저장할 리스트

for i in range(N):
    height = top[i]  # 현재 탑의 높이
    
    # Step 1: 스택에서 현재 탑보다 낮은 탑들 제거
    while stack and stack[-1][1] < height:
        stack.pop()
    
    # Step 2: 수신탑 찾기
    if stack:
        answer.append(stack[-1][0])
    else:
        answer.append(0)
    
    # Step 3: 현재 탑을 스택에 추가
    stack.append((i+1, height))

print(*answer)
```

## 새로 배운 개념

### 1. 스택(Stack) 자료구조

* 스택은 **"Last In First Out (LIFO)"** 구조다 - 나중에 들어간 게 먼저 나온다.
* 접시 쌓기를 생각하면 이해하기 쉽다: 맨 위에만 올리고, 맨 위 것만 뺄 수 있다.
* 파이썬에서는 리스트를 스택처럼 사용한다.
  - `append()`: 스택에 추가 (push)
  - `pop()`: 스택에서 제거 (pop)
  - `stack[-1]`: 맨 위 요소 확인 (peek)
  - `if stack:`: 스택이 비어있지 않은지 확인

### 2. 스택에 튜플 저장하기

* `stack.append((i+1, height))`처럼 (번호, 높이) 튜플을 저장할 수 있다.
* `stack[-1][0]`: 맨 위 튜플의 첫 번째 값 (번호)
* `stack[-1][1]`: 맨 위 튜플의 두 번째 값 (높이)

### 3. while문에서 and 조건의 순서

* `while stack and stack[-1][1] < height:` 
* **왼쪽 조건부터 순서대로** 확인한다.
* `stack`이 먼저 False면 `stack[-1][1]`은 확인조차 안 한다 (short-circuit).
* 이 순서가 중요한 이유: 빈 리스트에서 `stack[-1]`을 하면 **IndexError**가 발생한다.
* 순서를 바꾸면 에러가 나므로 반드시 존재 여부를 먼저 확인해야 한다.

### 4. 불필요한 데이터 제거 최적화

* 현재 탑보다 낮은 탑들은 앞으로 절대 신호를 받을 수 없다.
* 따라서 스택에서 제거해도 된다 → **메모리와 시간 절약**.
* "어떤 데이터를 버려도 되는가?"를 생각하는 것이 알고리즘 최적화의 핵심이다.

### 5. print(*answer) 언패킹

* `print(*answer)`는 리스트를 언패킹해서 공백으로 구분된 값들을 출력한다.
* `answer = [0, 0, 2, 2, 4]`일 때 `print(*answer)` → `0 0 2 2 4`
* `print(answer)`는 `[0, 0, 2, 2, 4]`처럼 대괄호까지 출력된다.
* 백준에서는 정확한 출력 형식이 중요하므로 `*` 언패킹을 자주 사용한다.

## 회고

* "왜 낮은 탑은 기억할 필요가 없는가?"를 이해하는 것이 이 문제의 핵심이었다. 더 높은 탑에 가려진 탑은 앞으로 쓸모가 없다는 논리를 깨달았다.
* `while stack and stack[-1][1] < height` 부분에서 왜 `stack`을 먼저 확인하는지 처음엔 몰랐는데, 순서가 바뀌면 에러가 난다는 것을 배웠다.
* 예제를 손으로 직접 따라가며 스택의 상태 변화를 그려보니 알고리즘의 동작 원리가 확실히 이해되었다.


# 알고리즘 문제 복습

## dailyalgo 168번

### 369게임 1
#### 문제 설명
369 게임은 1부터 n까지 순서대로 숫자를 외칠 때, 각 숫자의 어느 자리에든 3, 6, 9중 하나라도 포함되어 있으면, 그 숫자를 외치는 대신 손뼉을 치는 게임입니다. 예를 들어, 13을 외칠 차례라면, 일의 자리 숫자가 3이기 때문에 대신 손뼉을 칩니다.
즉, 숫자 13, 23, 30, 31, 39, 36 등, 각 자리 숫자에 3, 6, 9가 포함되어 있으면 무조건 손뼉을 칩니다. 단, 33과 같이 3, 6, 9 숫자가 두 번 이상 등장하더라도 손뼉을 두 번 치지는 않습니다. 무조건 한 번만 손뼉을 칩니다.

예를 들어, 1부터 10까지 진행할 경우 3, 6, 9에서 박수가 발생하여 총 3번의 손뼉을 치게 됩니다.

자연수 n이 주어졌을 때 1부터 n까지 369 게임 규칙에 따라 진행됐을 때 총 손뼉을 친 횟수를 반환하는 solution 함수를 작성하시오.

#### 제한 사항
n은 1 이상 10,000 이하의 자연수입니다.

```python
# 문자열로 바꾸고 3, 6, 9가 있으면 박수
# 손뼉의 횟수

def solution(n):
    answer = 0 # 손뼉 횟수 

    for i in range(1, n + 1):
        s = str(i)

        if '3' in s or '6' in s or '9' in s:
            answer += 1

    return answer

```
## dailyalgo 169번

### 369게임_2
#### 문제 설명
369 게임은 1부터 n까지 순서대로 숫자를 외칠 때, 각 숫자의 어느 자리에든 3, 6, 9중 하나라도 포함되어 있으면, 해당 숫자를 외치는 대신 3, 6, 9가 포함된 갯수만큼 손뼉을 치는 게임입니다.

예를 들어, 13, 36, 329, 999과 같은 숫자들은 아래와 같은 횟수로 손뼉을 칩니다.

13은 한 번
36과 329는 각각 두 번
999는 세 번
따라서, 1부터 37까지 369 게임을 진행할 경우 3, 6, 9, 13, 16, 19, 23, 26, 29, 30, 31, 32, 33(두 번), 34, 35, 36(두 번), 37은 숫자를 외치는 대신 손뼉을 칩니다. 이 때 손뼉을 친 횟수는 총 19번입니다.

자연수 n이 주어졌을 때 1부터 n까지 369 게임 규칙에 따라 진행됐을 때 총 손뼉을 친 횟수를 반환하는 solution 함수를 작성하시오.

#### 제한 사항
n은 1 이상 10,000 이하의 자연수입니다.

```python
# 문자열로 바꾸고 3, 6, 9가 있으면 박수
# 3, 6, 9의 갯수만큼 박수
# 3, 6, 9 갯수를 카운트 해야함

def solution(n):
    answer = 0

    for i in range(1, n + 1):
        s = str(i)
        for ch in s: # 문자 하나를 임시로 담는 변수 이름
            if ch in {'3', '6', '9'}: # 포함 여부만 확인할 때는 리스트보다 집합(set)을 쓰는 게 좋다.
                answer += 1

    return answer

# 숫자를 문자열로 바꾼 뒤, 각 자릿수를 하나씩 보면서 그자리가 3·6·9 중 하나일 때마다 손뼉 횟수를 1씩 늘린다.
```

## dailyalgo 202번

### 슬라이딩 윈도우 1
#### 문제 설명
슬라이딩 윈도우는 일정 크기의 구간(윈도우)을 배열의 시작부터 끝까지 한 칸씩 옮겨가며, 각 구간에 대해 연산을 수행하는 기법입니다.
정수로 이루어진 일차원 배열 numbers와 슬라이딩 윈도우의 구간 크기 window가 주어졌을 때, 배열의 시작부터 끝까지 크기가 window인 각 구간의 합을 차례로 담은 배열을 반환하는 solution 함수를 작성하시오.

예를 들어, numbers가 [4,1,5,0,-4,1,-10]이고, window가 3이라면
첫 번째 윈도우는 [4,1,5]이고 합은 10,
두 번째 윈도우는 [1,5,0]이고 합은 6,
세 번째 윈도우는 [5,0,-4]이고 합은 1,
네 번째 윈도우는 [0,-4,1]이고 합은 -3,
다섯 번째 윈도우는 [-4,1,-10]이고 합은 -13이 되어
[10,6,1,-3,-13]을 반환해야 합니다.

#### 제한 사항
numbers의 길이는 1 이상 1,000 이하입니다.
numbers의 각 원소는 -1,000 이상 1,000 이하의 정수입니다.
window는 1 이상 numbers의 길이 이하의 자연수입니다.

```python
# 마지막 시작 구간은 len(numbers) - window
def solution(numbers, window):
    answer = []

    for i in range(len(numbers) - window + 1):
        win_sum = sum(numbers[i : i + window]) # 슬라이싱 사용해 합계 구하기
        answer.append(win_sum)

    return answer
```

# 알고리즘 문제 복습
### dailyalgo 202번 다른 풀이
### 슬라이딩 윈도우 1
#### 문제 설명
슬라이딩 윈도우는 일정 크기의 구간(윈도우)을 배열의 시작부터 끝까지 한 칸씩 옮겨가며, 각 구간에 대해 연산을 수행하는 기법입니다.
정수로 이루어진 일차원 배열 numbers와 슬라이딩 윈도우의 구간 크기 window가 주어졌을 때, 배열의 시작부터 끝까지 크기가 window인 각 구간의 합을 차례로 담은 배열을 반환하는 solution 함수를 작성하시오.

예를 들어, numbers가 [4,1,5,0,-4,1,-10]이고, window가 3이라면
첫 번째 윈도우는 [4,1,5]이고 합은 10,
두 번째 윈도우는 [1,5,0]이고 합은 6,
세 번째 윈도우는 [5,0,-4]이고 합은 1,
네 번째 윈도우는 [0,-4,1]이고 합은 -3,
다섯 번째 윈도우는 [-4,1,-10]이고 합은 -13이 되어
[10,6,1,-3,-13]을 반환해야 합니다.

#### 제한 사항
numbers의 길이는 1 이상 1,000 이하입니다.
numbers의 각 원소는 -1,000 이상 1,000 이하의 정수입니다.
window는 1 이상 numbers의 길이 이하의 자연수입니다.

```python
#슬라이딩 윈도우의 핵심 목적은 중복 계산을 피해서 시간 복잡도를 줄이는 것
def solution(numbers, window):
    answer = []
    total = sum(numbers[:window])  # 첫 번째 윈도우의 합
    answer.append(total) # 첫 번째 결과 저장

# 첫 윈도우는 직접 합을 구해 초기값으로 사용

    for i in range(len(numbers) - window):

        total = total - numbers[i] + numbers[i+window] 
        # 이전 윈도우의 합(total)을 재사용. 빠져나가는 값: numbers[i], 새로 들어오는 값: numbers[i + window]
        answer.append(total)
    return answer
```


### dailyalgo 229번
### 제거된 수 찾기
#### 문제 설명
1부터 N까지 숫자가 모두 한 번씩 있어야 하는데, 그중 하나가 빠진 상태로 오름차순으로 정렬된 배열 numbers가 주어집니다. 빠진 숫자를 찾아서 반환하는 solution 함수를 작성하시오.

#### 제한 사항
numbers의 길이는 1 이상 1,000,000 이하입니다.
numbers의 각 원소는 1 이상 N(numbers의 길이 + 1) 이하의 정수입니다.
모든 원소는 중복되지 않고 오름차순으로 정렬되어 있습니다.

##### 정렬된 배열의 규칙성을 이용한 풀이
```python
# 처음 어긋나는 순간이 빠진 숫자
# 끝까지 정상 → 마지막 숫자가 빠짐

def solution(numbers):
    n = len(numbers) # 현재 배열의 길이


    for i in range(n):
        number = numbers[i]

        if number != i+1: # numbers[i] == i + 1
            return i+1
        
    return n+1 # 반복문이 끝날 때까지 한 번도 틀리지 않았을 경우 빠진 숫자는 마지막 숫자
```
##### 집합끼리 연산을 통한 방법
```python
def solution(numbers):
    n = len(numbers) # numbers에는 원래 있어야 할 숫자보다 1개 적음 
                     # 따라서 원래 숫자 개수 = n+1

    numbers_set = set(numbers) # set은 중복 자동 제거. 집합끼리 연산 가능
    full_set = set(range(1, n+2)) # 원래 숫자의 끝은 n+1이지만 range는 끝을 포함하지 않기 때문에 +1

    remain_set = full_set - numbers_set # 집합끼리의 연산을 하면 빠진 숫자가 나옴
    
    return remain_set.pop() # pop은 자료구조에서 값을 하나 꺼내는 동작
```
##### 전체 합 - 현재 합 = 빠진 원소임을 이용한 풀이
```python
def solution(numbers):
    N = len(numbers) + 1

    total_sum = N * (N + 1) // 2
    current_sum = sum(numbers)

    return total_sum - current_sum
```

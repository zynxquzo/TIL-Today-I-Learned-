# BAEKJOON 알고리즘 문제 풀이
## 2161번 : 카드 1
### 문제
N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.

이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.

예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 버린 카드들은 순서대로 1 3 2가 되고, 남는 카드는 4가 된다.

N이 주어졌을 때, 버린 카드들을 순서대로 출력하고, 마지막에 남게 되는 카드를 출력하는 프로그램을 작성하시오.

### 입력
첫째 줄에 정수 N(1 ≤ N ≤ 1,000)이 주어진다.

### 출력
첫째 줄에 버리는 카드들을 순서대로 출력한다. 제일 마지막에는 남게 되는 카드의 번호를 출력한다.

```python
# N장의 카드
# 제일 위: 1번 카드 / 제일 아래: N번 카드
# 1. 제일 위의 카드 버림 (popleft)
# 2.그 다음 위에 있는 카드를 제일 아래로 옮김 (append)
# 버린 카드를 순서대로 출력 (throw)
# 마지막에 남는 카드 출력 (final_left)

from collections import deque

N = int(input())

q = deque(range(1, N + 1)) # 카드는 1번부터니까

throw = [] # 버린 카드를 저장할 리스트

# 카드가 1장 남을 때까지 반복
while len(q) > 1:
    # 1) 제일 위 카드 버리고
    pop_el = q.popleft() 
    throw.append(pop_el) # throw 리스트에 버린 카드 추가
    
    # 2) 그 다음 카드 아래로 옮기기
    move = q.popleft()
    q.append(move)

last = q.popleft()
print(*throw, last) # *은 리스트의 요소 하나씩 풀어서 전달
```
## 1158번 : 요세푸스 문제
### 문제
요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)

### 출력
예제와 같이 요세푸스 순열을 출력한다.

```python
# 1번부터 N번까지 N명의 사람이 원을 그리며 앉아있음
# 순서대로 K번째 사람 제거
# 남은 사람들로 다시 원을 만들고 N명의 사람이 모두 제거될 때까지 반복
# While문 사용.

from collections import deque

N, K = map(int, input().split())

q = deque(range(1, N + 1))
result = []

while q: # while len(q) > 0:/  비어 있으면 False  안 비어 있으면 True
    for _ in range(K - 1): # K번째 앞 사람들을 뒤로 이동
        q.append(q.popleft())
    
    result.append(q.popleft()) # 그리고 맨 앞사람이 된 K번째 사람을 제거
print("<" + ", ".join(map(str, result)) + ">")
```

## 9012번 : 괄호
### 문제
괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 
여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 

### 입력
입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 

### 출력
출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 

```python
T = int(input())
for _ in range(T):
    s = input().strip() # 문자열 한 줄을 입력받아라
    # strip()은 입력 문자열 양 끝의 쓸데없는 공백/엔터를 제거
    count = 0

    for ch in s:
        if ch == '(':
            count += 1
        else:
            count -= 1
        if count < 0:
            print("NO")
            break
    else:
         if count == 0:
             print("YES")
         else:
             print("NO")
```

## 13335번 : 트럭
### 문제
강을 가로지르는 하나의 차선으로 된 다리가 하나 있다. 이 다리를 n 개의 트럭이 건너가려고 한다. 트럭의 순서는 바꿀 수 없으며, 트럭의 무게는 서로 같지 않을 수 있다. 다리 위에는 단지 w 대의 트럭만 동시에 올라갈 수 있다. 다리의 길이는 w 단위길이(unit distance)이며, 각 트럭들은 하나의 단위시간(unit time)에 하나의 단위길이만큼만 이동할 수 있다고 가정한다. 동시에 다리 위에 올라가 있는 트럭들의 무게의 합은 다리의 최대하중인 L보다 작거나 같아야 한다. 참고로, 다리 위에 완전히 올라가지 못한 트럭의 무게는 다리 위의 트럭들의 무게의 합을 계산할 때 포함하지 않는다고 가정한다.

예를 들어, 다리의 길이 w는 2, 다리의 최대하중 L은 10, 다리를 건너려는 트럭이 트럭의 무게가 [7, 4, 5, 6]인 순서대로 다리를 오른쪽에서 왼쪽으로 건넌다고 하자. 이 경우 모든 트럭이 다리를 건너는 최단시간은 아래의 그림에서 보는 것과 같이 8 이다.다리의 길이와 다리의 최대하중, 그리고 다리를 건너려는 트럭들의 무게가 순서대로 주어졌을 때, 모든 트럭이 다리를 건너는 최단시간을 구하는 프로그램을 작성하라.

### 입력
입력 데이터는 표준입력을 사용한다. 입력은 두 줄로 이루어진다. 입력의 첫 번째 줄에는 세 개의 정수 n (1 ≤ n ≤ 1,000) , w (1 ≤ w ≤ 100) and L (10 ≤ L ≤ 1,000)이 주어지는데, n은 다리를 건너는 트럭의 수, w는 다리의 길이, 그리고 L은 다리의 최대하중을 나타낸다. 입력의 두 번째 줄에는 n개의 정수 a1, a2, ⋯ , an (1 ≤ ai ≤ 10)가 주어지는데, ai는 i번째 트럭의 무게를 나타낸다.

### 출력
출력은 표준출력을 사용한다. 모든 트럭들이 다리를 건너는 최단시간을 출력하라.

```python
# 다리를 큐로 만들어서 매 초마다 한 칸씩 밀어냄

from collections import deque 

n, w, L = map(int, input().split())
# n : 트럭 개수
# w : 다리 길이 (다리 위에 동시에 있을 수 있는 칸 수)
# L : 다리가 버틸 수 있는 최대 무게

trucks = deque(map(int, input().split())) # 다리를 건너야 할 트럭들의 무게를 앞에서부터 하나씩 꺼낼 수 있도록 줄로 만듦

bridge = deque([0] * w) # 길이가 w인 다리를 만듦, 0은 아직 트럭이 없는 빈 칸

time = 0 # 전체 걸린 시간

current_weight = 0 # 현재 다리 위에 올라가 있는 트럭들의 무게 합

# 아직 건너지 않은 트럭이 있거나, 다리 위에 트럭이 남아 있다면 반복
while trucks or current_weight > 0:

    time += 1

    left = bridge.popleft()
    # 다리의 맨 앞 칸에서 트럭 하나(또는 0)를 꺼냄
    # 다리를 다 건넌 트럭

    current_weight -= left
    # 다리를 내려간 트럭의 무게를 현재 무게에서 빼줌

    # 다음 트럭을 다리에 올릴 수 있는지 확인
    if trucks and current_weight + trucks[0] <= L:
        truck = trucks.popleft()
        # 대기 중인 트럭 중 맨 앞 트럭을 하나 꺼냄

        bridge.append(truck)
        # 그 트럭을 다리 맨 뒤 칸에 올림

        current_weight += truck
        # 다리 위 총 무게에 추가
    else:
        bridge.append(0)
        # 트럭을 못 올리면 빈 칸(0)을 추가해서
        # 시간만 흐르게 함

# 모든 트럭이 다리를 건넌 후 걸린 시간 출력
print(time)
```

## 4949번 : 균형잡힌 세상
### 문제
세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.

정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.

문자열에 포함되는 괄호는 소괄호("()") 와 대괄호("[]")로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.

모든 왼쪽 소괄호("(")는 오른쪽 소괄호(")")와만 짝을 이뤄야 한다.
모든 왼쪽 대괄호("[")는 오른쪽 대괄호("]")와만 짝을 이뤄야 한다.
모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.
모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.
짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.
정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.

### 입력
각 문자열은 마지막 글자를 제외하고 영문 알파벳, 공백, 소괄호("( )"), 대괄호("[ ]")로 이루어져 있으며, 온점(".")으로 끝나고, 길이는 100글자보다 작거나 같다.

입력의 종료조건으로 맨 마지막에 온점 하나(".")가 들어온다.
### 출력
각 줄마다 해당 문자열이 균형을 이루고 있으면 "yes"를, 아니면 "no"를 출력한다.

```python
while True:
    s = input()
    if s == '.': # 입력의 종료조건
        break

    stack = []
    is_balanced = True

    for ch in s:
        if ch == '(' or ch == '[':
            stack.append(ch)
        
        elif ch == ')':  # 닫는 소괄호
            if not stack or stack[-1] != '(': # 스택에 아무것도 없는 상태이거나 스택의 마지막이 여는 소괄호가 아니면
                is_balanced = False # 균형잡힌 것이 아니다
                break
            stack.pop()
        
        elif ch == ']':  # 닫는 대괄호
            if not stack or stack[-1] != '[': # 스택에 아무것도 없는 상태이거나 스택의 마지막이 여는 대괄호가 아니면
                is_balanced = False
                break
            stack.pop()
        
        else:
            pass

    if is_balanced and not stack:
        print("yes")
    else:
        print("no")
```
#### 딕셔너리를 활용한 풀이
```python
from collections import deque  # 스택 용도(append/pop)로 사용할 deque

# 닫는 괄호 -> 여는 괄호 매핑
braket_dic = {
    ')': '(',
    ']': '['
}

# 여는 괄호들은 '포함 검사'를 자주 하므로 집합(set)으로 만들어 두면 의도가 명확함
# (참고: 아래 close_braket도 set으로 만들어 통일해도 됨)
open_braket = set(braket_dic.values())   # {'(', '['}

close_braket = braket_dic.keys()         # ')', ']'

while True:
    data = input()            # 한 줄 입력(문장의 끝은 '.')

    if data == '.':           # 종료 조건: 점 하나만 들어오면 끝
        break

    stack = deque()           # 여는 괄호를 쌓아둘 스택
    is_valid = True           # 일단 균형이 맞는다고 가정

    for s in data:            # s는 문자열에서 현재 확인 중인 문자 1개
        if s in open_braket:  # s가 '(' 또는 '[' 라면: 여는 괄호이므로
            stack.append(s)   # 스택에 쌓아둠(나중에 닫는 괄호가 나오면 짝을 확인해야 함)

        elif s in close_braket:  # s가 ')' 또는 ']' 라면: 닫는 괄호이므로
            # braket_dic[s]는 "이 닫는 괄호(s)와 짝인 여는 괄호"를 의미함
            # 예: s == ')' 이면 braket_dic[s] == '('
            if stack and stack[-1] == braket_dic[s]:  # 스택 top이 올바른 여는 괄호면
                stack.pop()      # 짝이 맞으니 pop해서 제거(매칭 완료)
            else:
                is_valid = False # 짝이 없거나 종류가 다르면 균형 깨짐
                break

    if stack:                  # 끝까지 봤는데 여는 괄호가 남아있으면(열고 안 닫힘)
        is_valid = False

    if is_valid:
        print('yes')
    else:
        print('no')
 ```
## 회고
알고리즘 문제를 풀 때 가장 중요한 점은 저번에도 언급했지만 그림을 그려보는 것이다. 저번보다 더 난이도가 높다면 높은 문제들을 보면서 머릿속에서는 조각 조각 아이디어가 떠오르지만 그 아이디어의 우선순위가 뭔지, 어떤 코드로 구성해야 할 지, 그 조각 조각의 아이디어 중 어떤 조각이 제일 처음에 와야하는 지는 아직도 잘 모르겠다. 그래도 그림을 통해 이해하고 논리 구조를 파악할 수 있는 게 처음보다는 좀 실력이 붙은 것 같다. (아주 미미한 것 같지만...) 하루 하루 미세하지만 성장하는 내 모습을 보며 노력해서 더욱 성장해야겠다는 생각을 들게 한다. 다른 사람들과 나를 비교하는 것이 아닌, 과거의 나와 비교하자.

# 알고리즘 문제 복습
### dailyalgo 202번 다른 풀이
### 슬라이딩 윈도우 1
```python
#슬라이딩 윈도우의 핵심 목적은 중복 계산을 피해서 시간 복잡도를 줄이는 것
def solution(numbers, window):
    answer = []
    total = sum(numbers[:window])  # 첫 번째 윈도우의 합
    answer.append(total) # 첫 번째 결과 저장

# 첫 윈도우는 직접 합을 구해 초기값으로 사용

    for i in range(len(numbers) - window):

        total = total - numbers[i] + numbers[i+window] 
        # 이전 윈도우의 합(total)을 재사용. 빠져나가는 값: numbers[i], 새로 들어오는 값: numbers[i + window]
        answer.append(total)
    return answer
```


### dailyalgo 229번
### 제거된 수 찾기
##### 정렬된 배열의 규칙성을 이용한 풀이
```python
# 처음 어긋나는 순간이 빠진 숫자
# 끝까지 정상 → 마지막 숫자가 빠짐

def solution(numbers):
    n = len(numbers) # 현재 배열의 길이


    for i in range(n):
        number = numbers[i]

        if number != i+1: # numbers[i] == i + 1
            return i+1
        
    return n+1 # 반복문이 끝날 때까지 한 번도 틀리지 않았을 경우 빠진 숫자는 마지막 숫자
```
##### 집합끼리 연산을 통한 방법
```python
def solution(numbers):
    n = len(numbers) # numbers에는 원래 있어야 할 숫자보다 1개 적음 
                     # 따라서 원래 숫자 개수 = n+1

    numbers_set = set(numbers) # set은 중복 자동 제거. 집합끼리 연산 가능
    full_set = set(range(1, n+2)) # 원래 숫자의 끝은 n+1이지만 range는 끝을 포함하지 않기 때문에 +1

    remain_set = full_set - numbers_set # 집합끼리의 연산을 하면 빠진 숫자가 나옴
    
    return remain_set.pop() # pop은 자료구조에서 값을 하나 꺼내는 동작
```
##### 전체 합 - 현재 합 = 빠진 원소임을 이용한 풀이
```python
def solution(numbers):
    N = len(numbers) + 1

    total_sum = N * (N + 1) // 2
    current_sum = sum(numbers)

    return total_sum - current_sum
```

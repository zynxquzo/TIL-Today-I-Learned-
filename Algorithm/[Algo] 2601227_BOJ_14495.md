# 📚 오늘의 알고리즘 (2026.01.27)

## ✅ 오늘 푼 문제

* **백준 14495번**: [피보나치 비스무리한 수열](https://www.acmicpc.net/problem/14495) (Silver 4)

---

## 💻 내 풀이

```python
import sys

# n을 입력받음 (1 ≤ n ≤ 116)
n = int(sys.stdin.readline())

# 1. n의 최대 범위(116)를 고려하여 넉넉하게 리스트 생성 (IndexError 방지)
dp = [0] * 117

# 2. 초기값 설정 (f(1)=1, f(2)=1, f(3)=1)
dp[1] = 1
dp[2] = 1
dp[3] = 1

# 3. 점화식 적용: f(n) = f(n-1) + f(n-3)
for i in range(4, n + 1):
    dp[i] = dp[i-1] + dp[i-3]

# 4. 결과 출력
print(dp[n])

```

## 📖 새로 배운 개념

### 1. 동적 계획법(Dynamic Programming)의 기초

* 큰 문제를 작은 문제로 나누어 푸는 방식입니다.
* 한 번 계산한 값을 리스트(`dp`)에 저장해두고 재사용하는 것이 핵심입니다.
* 문제에서 주어진 규칙(`f(n-1) + f(n-3)`)을 점화식으로 코드로 옮기는 연습을 했습니다.

### 2. IndexError와 리스트의 미리 확보(Padding)

* `dp = [0] * (n + 1)`처럼 입력값에 딱 맞춰 리스트를 생성하면, 이 작을 때 미리 선언한 `dp[3]` 등의 위치가 없어 에러가 발생할 수 있습니다.
* **해결책**: 문제에서 주어진 **$n$의 최댓값(116)**을 확인하고, dp = [0] * 117처럼 넉넉한 크기의 리스트를 미리 만들어두면 어떤 입력값이 와도 안전하게 초기값을 설정할 수 있습니다.

## 🤔 회고 (Self Feedback)

* 처음에는 알고 있던 피보나치 수열과 비슷하게 생각했지만, 문제에서 준 점화식의 차이를 정확히 읽는 것이 중요하다는 걸 깨달았습니다.
* 리스트 인덱스 에러를 해결할 때, 조건문을 여러 개 쓰는 것보다 문제의 범위만큼 미리 공간을 확보하는 방식이 코드를 훨씬 간결하고 안전하게 만든다는 점이 인상적이었습니다.

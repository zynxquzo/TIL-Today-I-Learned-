# RESTful API
### 인터페이스

인터페이스는 서로 다른 두 개의 시스템이나 장치가 정보를 주고받을 때 발생하는 접점 또는 경계면을 의미한다.

- GUI
사용자가 아이콘이나 버튼 같은 그래픽 요소를 통해 컴퓨터와 상호작용하는 환경이다.
- CLI
사용자가 텍스트 기반의 명령어를 직접 입력하여 컴퓨터와 상호작용하는 환경이다.

### API

API(Application Programming Interface)는 소프트웨어 애플리케이션이 서로 데이터를 주고받으며 기능을 수행할 수 있도록 정의한 규격이다. 
한 프로그램의 기능을 다른 프로그램에서도 활용할 수 있게 해주는 징검다리 역할을 수행한다.

## RESTful API 아키텍처

RESTful API는 웹의 기존 기반 시설을 최대한 활용하여 리소스를 효율적으로 관리하기 위한 설계 지침이다. 이는 두 컴퓨터 시스템이 인터넷을 통해 정보를 안전하고 표준화된 방식으로 교환하게 한다.

### REST API 설계의 주요 특징

- 클라이언트와 서버의 분리
사용자 인터페이스를 담당하는 클라이언트와 데이터 처리를 담당하는 서버의 역할을 명확히 나누어 독립적으로 발전할 수 있게 한다.
- 무상태성
서버는 클라이언트의 이전 요청 상태를 저장하지 않는다. 모든 요청은 독립적이며 처리에 필요한 모든 정보를 스스로 포함해야 한다.
- 캐시 처리 가능
웹의 기존 인프라를 활용하여 응답 데이터를 임시로 저장할 수 있다. 이를 통해 네트워크 효율을 높이고 서버의 부하를 줄인다.
- 계층화 시스템
클라이언트는 서버에 직접 연결되는지 혹은 중간 서버를 거치는지 알 수 없다. 보안이나 로드 밸런싱을 위한 계층 구성을 자유롭게 할 수 있다.
- 인터페이스의 일관성
자원을 정의하고 조작하는 방식이 규격화되어 있어 플랫폼에 상관없이 동일한 방식으로 데이터에 접근할 수 있다.
## 요청의 구조와 구성 요소

웹 API에서 요청(Request)은 서버에 특정 자원을 요구하거나 동작을 지시하는 행위이다.

### URI(Uniform Resource Identifier)

인터넷상의 자원을 고유하게 식별하기 위한 체계이다.

- URL(Uniform Resource Locator)
자원이 어디에 위치하는지 나타내는 물리적인 주소이다.
- URN(Uniform Resource Name)
위치와 상관없이 자원에 부여된 고유한 이름이다.
### URL의 세부 구성
- Scheme
    
    데이터 전송에 사용하는 통신 규약이다. 보통 보안이 강화된 HTTPS를 사용한다.
    
- Domain name
    
    자원이 보관된 웹 서버의 주소 또는 아이피 주소이다.
    
- Port
    
    서버의 특정 서비스에 접근하기 위한 통로 번호이다. http - 80 / https - 443으로 약속이 되어있으며, 웹 서비스는 대개 생략 가능하다.
    
- path to the file
    
    서버 내부에서 실제 자원이 위치한 상세 경로를 나타낸다.
    
- Parameters (query parameter)
    
    서버에 전달하는 추가적인 조건 정보이다. 물음표 뒤에 `&`로 구분되는 키와 값의 형태로 구성한다.
    
- Anchor
    
    문서 내부의 특정 위치를 가리키는 책갈피와 같은 역할을 한다.

  ### HTTP method

서버에 데이터 처리를 요청할 때 사용하는 주요 방식들이다.

- GET
    
    서버로부터 데이터를 가져올 때 사용한다.
    
- POST
    
    새로운 데이터를 생성하여 서버에 보낼 때 사용한다.
    
- PUT
    
    기존 데이터를 새로운 내용으로 완전히 교체할 때 사용한다.
    
- DELETE
    
    특정 데이터를 삭제할 때 사용한다.
    

---
## API 엔드포인트

엔드포인트는 API가 리소스에 접근하기 위해 외부로 노출한 특정 주소이다.

API 엔드포인트는 리소스에 접근하는 진입점이며, 이를 설계할 때는 리소스 중심의 구조를 갖추는 것이 핵심이다. 좋은 엔드포인트 설계는 문서 없이도 주소만 보고 그 역할을 짐작할 수 있게 한다.

---

### 리소스를 나타내는 명사 중심의 설계

엔드포인트의 주소에는 동작을 나타내는 동사 대신 관리하고자 하는 대상인 명사를 사용한다. 어떤 행위를 할 것인지는 주소가 아니라 HTTP 메서드가 결정한다.

- 잘못된 예시
가져오기 주소: /get_users
생성하기 주소: /create_user
- 올바른 예시
사용자 목록 관련 주소: /users

### 복수 명사 사용의 일관성

대부분의 리소스는 여러 개의 모음을 다루거나 그중 하나를 선택하는 경우가 많다. 따라서 리소스 이름은 단수형보다 복수형인 복수 명사를 사용하는 것이 관례이다.

- 예시: /users, /posts, /products

이렇게 설계하면 전체 목록을 다루는 요청과 특정 항목을 다루는 요청을 일관되게 표현할 수 있다.

---

### 계층 관계를 나타내는 경로 구조

자원 간에 포함 관계가 있거나 종속적인 관계가 있을 때는 슬래시를 사용하여 계층 구조를 나타낸다.

- 예시: /users/1/orders
이 주소는 아이디가 1인 사용자의 주문 목록이라는 의미를 직관적으로 전달한다.
### 경로 변수와 쿼리 매개변수의 구분

데이터를 식별하거나 필터링할 때 어떤 방식을 사용할지 명확히 정해야 한다.

- 경로 변수(path variable)
    
    특정 자원을 유일하게 식별할 때 사용한다. 주소의 경로 일부로 포함된다.
    
    - 예시: /users/123
- 쿼리 매개변수(query parameter)
    
    정렬, 필터링, 검색 등 보조적인 조건을 추가할 때 사용한다. 물음표 뒤에 위치한다.
    
    - 예시: /users?role=admin&sort=created_at
    이 주소는 관리자 권한을 가진 사용자를 가입일 순으로 정렬하여 보여달라는 의미이다.

---

### API 버전 관리

시스템이 업데이트되면서 엔드포인트의 구조가 바뀔 수 있다. 기존에 서비스를 이용하던 사용자의 불편을 최소화하기 위해 주소에 버전을 명시한다.

- 예시: /v1/users, /v2/users

버전을 포함하면 새로운 기능을 도입하면서도 이전 버전의 안정성을 유지할 수 있다.

---

### 하이픈을 사용한 가독성 향상

주소에 여러 단어가 포함될 경우 가독성을 위해 하이픈을 사용한다. 밑줄이나 대문자 혼용은 권장하지 않는다.

- 좋은 예시: /user-profiles
- 나쁜 예시: /user_profiles, /userProfiles

# 오늘의 알고리즘
## BAEKJOON 2309번
### 일곱 난쟁이
#### 문제
왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다. 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.

아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다. 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.

아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.

#### 입력
아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다. 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.

#### 출력
일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.
```python
dwarfs = []

for _ in range(9):
    height = int(input())
    dwarfs.append(height)
    
total_sum = sum(dwarfs)
# dwarfs = [int(input()) for _ in range(9)]

fake_1 = 0
fake_2 = 0

for i in range(9):
    for j in range(i+1, 9):
        if total_sum - (dwarfs[i] + dwarfs[j]) == 100:
            fake_1 = dwarfs[i]
            fake_2 = dwarfs[j]
            break
dwarfs.remove(fake_1)
dwarfs.remove(fake_2)

dwarfs.sort()

for d in dwarfs:
    print(d)
```

# 📚 오늘의 알고리즘 (2026.01.29)

## ✅ 오늘 푼 문제

* **백준 1436번**: [영화감독 숌](https://www.acmicpc.net/problem/1436) (Silver 5)

---

## 💻 내 풀이

```python
import sys

N = int(sys.stdin.readline())  # 입력: N번째 종말의 수를 찾아야 함

num = 666  # 확인할 숫자 (첫 번째 종말의 수인 666부터 시작)
count = 0  # 지금까지 찾은 종말의 수의 개수

while count < N:  # N개를 찾을 때까지 반복
    if '666' in str(num):  # 현재 숫자를 문자열로 바꿔서 "666"이 포함되어 있는지 확인
        count += 1  # 종말의 수를 찾았으면 개수를 1 증가
    num += 1  # 다음 숫자로 이동 (666 → 667 → 668 → ...)

print(num - 1)  # 반복문이 끝났을 때 num은 1 증가한 상태이므로 1을 빼서 출력
```

## 📖 새로 배운 개념

### 1. 브루트포스(Brute Force) 접근법

* 복잡한 규칙을 찾으려 하지 않고 가능한 모든 경우를 직접 확인하는 방식입니다.
* 이 문제에서는 666부터 시작해서 하나씩 증가하며 "666"이 포함된 수를 세는 단순한 방법이 가장 효과적이었습니다.
* 처음에는 패턴을 찾으려 했지만 실제로는 순차적으로 확인하는 것이 더 명확하고 정확한 해결책이었습니다.

### 2. 문자열 포함 여부 확인

* `"666" in str(num)`을 사용하면 숫자 안에 특정 문자열이 포함되어 있는지 쉽게 확인할 수 있습니다.
* 숫자를 문자열로 변환(`str()`)한 후 `in` 연산자를 사용하는 방식입니다.

### 3. while 반복문의 조건과 변수 증가 타이밍

* `count < N`과 `count <= N`의 차이를 정확히 이해해야 합니다.
* `count < N`을 사용하는 이유는 count가 N개가 되면 즉시 반복을 멈춰야 하기 때문입니다.
* `count <= N`을 사용하면 count가 N과 같아져도 계속 반복하므로 무한루프가 발생합니다.

### 4. 반복문 종료 후 변수 값 조정

* while 반복문 안에서 `num += 1`을 매번 실행하기 때문에 반복문이 종료될 때 num은 실제 답보다 1 큰 상태입니다.
* 실행 순서를 보면 "666을 찾음 → count 증가 → num도 증가 → 조건 확인 → 종료"이므로 마지막에 num이 한 번 더 증가합니다.
* 따라서 출력할 때 `num - 1`을 해줘야 정확한 N번째 종말의 수를 얻을 수 있습니다.

## 🤔 회고 (Self Feedback)

* 처음에는 종말의 수의 패턴을 찾아서 수식으로 해결하려고 했지만 실제로는 단순하게 하나씩 확인하는 방법이 더 정확했습니다.
* while 반복문의 조건(`<` vs `<=`)과 변수 증가 시점에 대해 혼란스러웠는데 실제 실행 과정을 단계별로 따라가보니 명확하게 이해할 수 있었습니다.
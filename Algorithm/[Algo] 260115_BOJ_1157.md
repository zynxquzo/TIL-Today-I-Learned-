# 오늘의 알고리즘 (2026.01.15)

## 오늘 푼 문제

* **백준 1157번**: [단어 공부](https://www.acmicpc.net/problem/1157) (Bronze 1)

---

## 내 풀이

```python
# 문자를 대문자로 통일
word = input().upper()

# 빈 딕셔너리 생성
counts = {}

# 딕셔너리로 개수 세기
for ch in word:
    if ch in counts:
        counts[ch] += 1
    else:
        counts[ch] = 1

# 최댓값 찾고 판별
max_count = max(counts.values())

# 최댓값 알파벳 저장
best_ch = []
for ch, count in counts.items():
    if count == max_count:
        best_ch.append(ch)

# 결과 출력
if len(best_ch) > 1:
    print('?')
else:
    print(best_ch)
```

## 새로 배운 개념

### 1. 딕셔너리로 빈도 세기

* 문자열에서 각 알파벳이 몇 번 나왔는지 세기 위해 딕셔너리를 사용했다.
* `if ch in counts`로 키 존재 여부를 확인하고, 있으면 `+1`, 없으면 `1`로 초기화한다.
* 이렇게 하면 길이가 매우 긴 문자열도 한 번 순회하면서 빈도를 셀 수 있다.

### 2. 최댓값과 해당 키 찾기

* `max(counts.values())`로 가장 큰 빈도 수를 구했다.
* 다시 `for ch, count in counts.items()`를 돌면서 최댓값과 같은 알파벳들을 `best_ch` 리스트에 모았다.
* 최댓값을 먼저 구하고, 그 값과 같은 항목만 모으는 방식은 "최댓값 후보가 여러 개일 때" 자주 쓰는 패턴이다.

### 3. 조건에 따라 다른 출력 처리

* 가장 많이 나온 알파벳이 여러 개면 `?`, 하나면 그 알파벳을 출력해야 한다.
* `if len(best_ch) > 1:`처럼 리스트 길이로 분기해 요구사항을 만족시켰다.
* 문제에서 요구하는 출력 형식을 코드로 정확히 옮기는 연습이 되었다.

## 회고

* 대소문자를 구분하지 않기 위해 입력을 한 번에 `upper()`로 통일해두는 것이 깔끔했다.
* 처음에는 리스트로만 풀려고 했지만, 딕셔너리를 쓰면 각 알파벳의 빈도를 관리하기 훨씬 편하다는 걸 느꼈다.


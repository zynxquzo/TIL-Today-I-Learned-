# 오늘의 알고리즘
## BAEKJOON : 1934번
### 최소공배수
```python
# 테스트 케이스 개수 입력
T = int(input())

for _ in range(T):
    A, B = map(int, input().split())

    # 처음 값을 보관 (나중에 최소공배수 계산 시 사용)
    original_a = A
    original_b = B

	  # 유클리드 호제법으로 최대공약수(GCD) 구하기
    while B != 0:
        r = A % B
        A = B
        B = r
        # A는 최소공배수, B는 0
        
    # 최소공배수(LCM) 공식: (A * B) // 최대공약수
    answer = (original_a * original_b) // A
    print(answer)
```
**입력**
```text
3
1 45000
6 10
13 17
```

**출력**
```text
45000
30
221
```
### 유클리드 호제법 (Euclidean Algorithm)
- 최대공약수(GCD)를 구하는 가장 효율적인 방법.
- **핵심 로직**: `A % B`의 나머지가 0이 될 때까지 나누는 과정을 반복한다.

---

### 오늘의 핵심 코드
> **최대공약수를 이용한 최소공배수 도출**

### 어려웠던 점 & 해결 방법

#### 1. 변수 값 소실 문제
* **문제**: `while`문을 통해 최대공약수(GCD)를 구하는 과정에서 `A`와 `B`의 값이 계속 변하여, 최소공배수(LCM) 계산에 필요한 원래의 입력값이 사라지는 현상이 발생했습니다.
* **해결**: `while`문을 실행하기 전, `original_a`와 `original_b`라는 변수를 만들어 입력받은 값을 미리 복사해둠으로써 해결했습니다.

#### 2. 들여쓰기(Indentation) 오류
* **문제**: `answer` 계산식과 `print()` 함수를 `while`문 내부에 들여쓰기하여 작성했더니, 최대공약수가 완전히 구해지기 전의 중간 단계 값들이 반복적으로 계산되고 출력되었습니다.
* **해결**: 파이썬의 들여쓰기 규칙을 다시 확인하고, 반복이 완전히 끝난 후(B가 0이 된 후)에 결과값을 도출하도록 `while`문 밖으로 코드 위치를 조정했습니다.
